include:
  # - template: Workflows/MergeRequest-Pipelines.gitlab-ci.yml
  - local: .gitlab/templates.yml

# variables:
#   DOCKER_HOST: tcp://docker:2376
#   DOCKER_TLS_CERTDIR: '/certs'
#   # These are usually specified by the entrypoint, however the
#   # Kubernetes executor doesn't run entrypoints
#   # https://gitlab.com/gitlab-org/gitlab-runner/-/issues/4125
#   DOCKER_TLS_VERIFY: 1
#   DOCKER_CERT_PATH: '$DOCKER_TLS_CERTDIR/client'
#   CONTAINER_TEST_IMAGE: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG
#   CONTAINER_RELEASE_IMAGE: $CI_REGISTRY_IMAGE:latest

# stages:
#   # - setup
#   # - main
#   # - build
#   - release
#   # - deploy

variables:
  RELEASE_COMMIT_PATTERN: /^chore\(release\)/

stages:
    # - build
    - test
    - package
    - release

.pre-release-job:
  extends: [.node-job]
  before_script:
    - apk add --no-cache git
    - touch CHANGELOG.md
  only:
    refs:
      - tags
    variables:
      - $CI_COMMIT_MESSAGE !~ $RELEASE_COMMIT_PATTERN
  artifacts:
    paths:
      - CHANGELOG.md

.release-job:
  only:
    refs:
      - tags
    variables:
      - $CI_COMMIT_MESSAGE =~ $RELEASE_COMMIT_PATTERN && $CI_COMMIT_TAG 

Release:
  extends: [.release-job]
  stage: release
  script:
    - echo "Deploying to production"
    
Test MR:
  stage: test
  only:
    - merge_requests
  image: node:16.14.2-alpine
  script:
    - echo "Hello World"

Setup Package:
  extends: [.pre-release-job]
  stage: package
  before_script:
    - !reference [.pre-release-job, before_script]
    - npm install @semantic-release/gitlab @semantic-release/commit-analyzer @semantic-release/release-notes-generator @semantic-release/changelog
  script:
    - npx semantic-release


# install-dependencies:
#   stage: setup
#   extends: [.node-job]
#   cache:
#     key: !reference [.node-job, cache, key]
#     paths: !reference [.node-job, cache, paths]
#     policy: pull-push
#   script:
#     - echo "Done!..."
#   rules:
#     - changes:
#         - package-lock.json

# main:
#   stage: main
#   extends: [.node-job, .require-install-deps]
#   before_script:
#     - apk add --no-cache git
#     - !reference [.node-job, before_script]
#   script:
#     - npx prettier --check src/**/*.ts
#     - npx eslint src/**/*.ts
#     - npm run build
#   artifacts:
#     paths:
#       - dist/

# build:
#   dependencies:
#     - main
#   stage: build
#   image: docker:20.10.12-dind
#   services:
#     - docker:20.10.12-dind
#   before_script:
#     - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
#   script:
#     # fetches the latest image (not failing if image is not found)
#     - docker pull $CONTAINER_TEST_IMAGE || true
#     # builds the project, using OCI labels, notice the cache-from, which is going
#     # to use the image we just pulled locally the built image is tagged locally with
#     # the commit SHA, and then pushed to the GitLab registry
#     - >
#       docker build
#       --cache-from $CONTAINER_TEST_IMAGE
#       --label "org.opencontainers.image.title=$CI_PROJECT_TITLE"
#       --label "org.opencontainers.image.url=$CI_PROJECT_URL"
#       --label "org.opencontainers.image.created=$CI_JOB_STARTED_AT"
#       --label "org.opencontainers.image.revision=$CI_COMMIT_SHA"
#       --label "org.opencontainers.image.version=$CI_COMMIT_REF_NAME"
#       --progress auto
#       --tag $CONTAINER_TEST_IMAGE
#       .
#     - docker push $CONTAINER_TEST_IMAGE


# TODO: Add build for release
# TODO: Add release image only for master
# release-image:
#   image: docker:20.10.12-dind
#   stage: release
#   when: manual
#   services:
#     - docker:20.10.12-dind
#   before_script:
#     - echo "Releasing..."
#     - echo $CONTAINER_RELEASE_IMAGE:$CI_COMMIT_SHA
#     - echo $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
#     - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
#   script:
#     - docker pull $CI_REGISTRY_IMAGE:latest
#     - docker tag $CI_REGISTRY_IMAGE:$latest $CONTAINER_RELEASE_IMAGE:$CI_COMMIT_SHA
#     - docker push $CONTAINER_RELEASE_IMAGE:latest
#   needs:
#     - build
#   only:
#     - main

# deploy:
#   stage: deploy
#   image:
#     name: dtzar/helm-kubectl:3.8.2
#     entrypoint: ['']
#   variables:
#     IMAGE_COFIG: --set-string imageCredentials.username=$DEPLOY_USER
#       --set-string imageCredentials.password=$DEPLOY_TOKEN
#       --set-string imageCredentials.registry=$CI_REGISTRY
#       --set-string image.tag=$CI_COMMIT_REF_SLUG
#       --set-string image.repository=$CI_REGISTRY_IMAGE
#     ENV_CONFIG: --set-string env.normal.PORT=$PORT
#       --set-string env.normal.AWS_REGION=$AWS_REGION
#       --set-string env.normal.AWS_ARTISTS_BUCKET=$AWS_ARTISTS_BUCKET
#       --set-string env.normal.CLOUD_FRONT_URL=$CLOUD_FRONT_URL
#       --set-string env.secret.JWT_ISSUER=$JWT_ISSUER
#       --set-string env.secret.JWT_SECRET_KEY=$JWT_SECRET_KEY
#       --set-string env.secret.JWT_EXPIRATION=$JWT_EXPIRATION
#       --set-string env.secret.AWS_ACCESS_KEY=$AWS_ACCESS_KEY
#       --set-string env.secret.AWS_ACCESS_SECRET=$AWS_ACCESS_SECRET
#       --set-string env.secret.SMS_AWS_ACCESS_KEY=$SMS_AWS_ACCESS_KEY
#       --set-string env.secret.SMS_AWS_ACCESS_SECRET=$SMS_AWS_ACCESS_SECRET
#       --set-string env.secret.DB_HOST=$DB_HOST
#       --set-string env.secret.DB_PASSWORD=$DB_PASSWORD
#       --set-string env.secret.DB_USERNAME=$DB_USERNAME
#       --set-string env.secret.DB_PORT=$DB_PORT
#       --set-string env.secret.TYPEORM_SYNC=$TYPEORM_SYNC
#     NAMESPACE: development
#     VALUES_PATH: ./deploy/values.yaml
#     CHART_NAME: $CI_PROJECT_TITLE
#   before_script:
#     - kubectl config get-contexts
#     - kubectl config use-context inker-studio/inker-terraform-gke:gke-agent
#   script:
#     - helm upgrade $CHART_NAME ./deploy --install
#       $IMAGE_COFIG $ENV_CONFIG
#       --namespace $NAMESPACE
#       --values $VALUES_PATH
#       --cleanup-on-fail
#       --timeout 5m
#       --wait
