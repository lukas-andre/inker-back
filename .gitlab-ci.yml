# File: .gitlab-ci.yml
include:
  - local: .gitlab/base.yml
  - local: .gitlab/rules.yml
  - local: .gitlab/cache.yml

stages:
  - setup
  - verify
  - build
  - release
  - deploy

variables:
  RELEASE_COMMIT_PATTERN: /^chore\(release\)/
  MERGE_COMMIT_PATTERN: /^Merge branch/
  REGISTRY_URL: registry.inker.studio
  CONTAINER_TEST_IMAGE: $REGISTRY_URL/$CI_PROJECT_PATH:$CI_COMMIT_REF_SLUG
  CONTAINER_RELEASE_IMAGE: $REGISTRY_URL/$CI_PROJECT_PATH:latest
  CONTAINER_STAGING_IMAGE: $REGISTRY_URL/$CI_PROJECT_PATH:staging
  BUILDKIT_PROGRESS: plain
  DOCKER_BUILDKIT: "1"
  COMPOSE_DOCKER_CLI_BUILD: "1"

default:
  tags:
    - inker
  interruptible: true
  timeout: 30m

# Stage: Setup
Install Dependencies:
  stage: setup
  extends: 
    - .node-job
    - .setup-cache
  script:
    - npm ci --prefer-offline --no-audit --include=dev
    - npm run prepare || true
  artifacts:
    paths:
      - node_modules/
    expire_in: 1 day
  rules:
    - !reference [.changes-package, rules]

# Stage: Verify
Verify:
  stage: verify
  extends: 
    - .node-job
    - .verify-cache
  needs: ["Install Dependencies"]
  dependencies:
    - Install Dependencies
  script:
    # - npm run lint || true
    # - npm run test -- --ci --coverage || true
    - npm run build --configuration production
  coverage: '/All files[^|]*\|[^|]*\s+([\d\.]+)/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
    paths:
      - dist/
      - coverage/
    expire_in: 1 day
  rules:
    - !reference [.changes-src, rules]

# Stage: Build
Build Image:
  stage: build
  extends: .docker-job
  needs: ["Verify"]
  dependencies:
    - Verify
  variables:
    BRANCH_TAG: $REGISTRY_URL/$CI_PROJECT_PATH:$CI_COMMIT_REF_SLUG
    SHA_TAG: $REGISTRY_URL/$CI_PROJECT_PATH:$CI_COMMIT_SHA
  script:
    - docker build -t $BRANCH_TAG -t $SHA_TAG .
    - docker push $BRANCH_TAG
    - docker push $SHA_TAG
  rules:
    - !reference [.changes-docker, rules]

# Stage: Deploy - Staging
Deploy to Staging:
  stage: deploy
  image: docker:24.0.7
  services:
    - docker:24.0.7-dind
  needs: ["Build Image"]
  variables:
    DOCKER_HOST: unix:///var/run/docker.sock
    DOCKER_TLS_CERTDIR: ""
    DOCKER_DRIVER: overlay2
    # Environment
    ENV: development
    # Application configuration for staging
    PORT: 3000
    DB_HOST: postgresql_development
    DB_PASSWORD: ${STAGING_DB_PASSWORD:-devpassword123}
    DB_USERNAME: ${STAGING_DB_USERNAME:-postgres_dev}
    DB_PORT: 5432
    TYPEORM_SYNC: "true"
    AWS_ACCESS_KEY: ${STAGING_AWS_ACCESS_KEY}
    AWS_ACCESS_SECRET: ${STAGING_AWS_ACCESS_SECRET}
    SMS_AWS_ACCESS_KEY: ${STAGING_SMS_AWS_ACCESS_KEY}
    SMS_AWS_ACCESS_SECRET: ${STAGING_SMS_AWS_ACCESS_SECRET}
    AWS_REGION: ${AWS_REGION:-us-east-1}
    AWS_ARTISTS_BUCKET: ${STAGING_AWS_ARTISTS_BUCKET}
    CLOUD_FRONT_URL: ${STAGING_CLOUD_FRONT_URL}
    JWT_ISSUER: staging.inker.studio
    JWT_SECRET_KEY: ${STAGING_JWT_SECRET_KEY}
    JWT_EXPIRATION: ${JWT_EXPIRATION:-7d}
    TZ: "America/Santiago"
    SENDGRID_API_KEY: ${STAGING_SENDGRID_API_KEY}
  script:
    - cd /apps/api
    - docker network ls
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $REGISTRY_URL
    # Stop and remove old container if exists
    - docker compose --project-name inkerstudio_development down || true
    # Deploy with all environment variables
    - |
      ENV=${ENV} \
      PORT=${PORT} \
      DB_HOST=${DB_HOST} \
      DB_PASSWORD=${DB_PASSWORD} \
      DB_USERNAME=${DB_USERNAME} \
      DB_PORT=${DB_PORT} \
      TYPEORM_SYNC=${TYPEORM_SYNC} \
      AWS_ACCESS_KEY=${AWS_ACCESS_KEY} \
      AWS_ACCESS_SECRET=${AWS_ACCESS_SECRET} \
      SMS_AWS_ACCESS_KEY=${SMS_AWS_ACCESS_KEY} \
      SMS_AWS_ACCESS_SECRET=${SMS_AWS_ACCESS_SECRET} \
      AWS_REGION=${AWS_REGION} \
      AWS_ARTISTS_BUCKET=${AWS_ARTISTS_BUCKET} \
      CLOUD_FRONT_URL=${CLOUD_FRONT_URL} \
      JWT_ISSUER=${JWT_ISSUER} \
      JWT_SECRET_KEY=${JWT_SECRET_KEY} \
      JWT_EXPIRATION=${JWT_EXPIRATION} \
      TZ=${TZ} \
      SENDGRID_API_KEY=${SENDGRID_API_KEY} \
      CI_COMMIT_SHA=${CI_COMMIT_SHA} \
      docker compose --project-name inkerstudio_development -f docker-compose.yml up -d
  environment:
    name: staging
    url: https://staging.inker.studio
  rules:
    - if: '$CI_COMMIT_BRANCH == "develop"'
      when: on_success
    - if: '$CI_COMMIT_BRANCH == "staging"'
      when: on_success
    - when: manual
      allow_failure: true

# Stage: Deploy - Production
Deploy to Production:
  stage: deploy
  image: docker:24.0.7
  services:
    - docker:24.0.7-dind
  needs: ["Build Image"]
  variables:
    DOCKER_HOST: unix:///var/run/docker.sock
    DOCKER_TLS_CERTDIR: ""
    DOCKER_DRIVER: overlay2
    # Environment
    ENV: production
    # Application configuration for production
    PORT: 3000
    DB_HOST: postgresql_production
    DB_PASSWORD: ${DB_PASSWORD}
    DB_USERNAME: ${DB_USERNAME}
    DB_PORT: 5432
    TYPEORM_SYNC: "false"
    AWS_ACCESS_KEY: ${AWS_ACCESS_KEY}
    AWS_ACCESS_SECRET: ${AWS_ACCESS_SECRET}
    SMS_AWS_ACCESS_KEY: ${SMS_AWS_ACCESS_KEY}
    SMS_AWS_ACCESS_SECRET: ${SMS_AWS_ACCESS_SECRET}
    AWS_REGION: ${AWS_REGION:-us-east-1}
    AWS_ARTISTS_BUCKET: ${AWS_ARTISTS_BUCKET}
    CLOUD_FRONT_URL: ${CLOUD_FRONT_URL}
    JWT_ISSUER: www.inker.studio
    JWT_SECRET_KEY: ${JWT_SECRET_KEY}
    JWT_EXPIRATION: ${JWT_EXPIRATION:-7d}
    TZ: "America/Santiago"
    SENDGRID_API_KEY: ${SENDGRID_API_KEY}
  script:
    - cd /apps/api
    - docker network ls
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $REGISTRY_URL
    # Stop and remove old container if exists
    - docker compose --project-name inkerstudio_production down || true
    # Deploy with all environment variables
    - |
      ENV=${ENV} \
      PORT=${PORT} \
      DB_HOST=${DB_HOST} \
      DB_PASSWORD=${DB_PASSWORD} \
      DB_USERNAME=${DB_USERNAME} \
      DB_PORT=${DB_PORT} \
      TYPEORM_SYNC=${TYPEORM_SYNC} \
      AWS_ACCESS_KEY=${AWS_ACCESS_KEY} \
      AWS_ACCESS_SECRET=${AWS_ACCESS_SECRET} \
      SMS_AWS_ACCESS_KEY=${SMS_AWS_ACCESS_KEY} \
      SMS_AWS_ACCESS_SECRET=${SMS_AWS_ACCESS_SECRET} \
      AWS_REGION=${AWS_REGION} \
      AWS_ARTISTS_BUCKET=${AWS_ARTISTS_BUCKET} \
      CLOUD_FRONT_URL=${CLOUD_FRONT_URL} \
      JWT_ISSUER=${JWT_ISSUER} \
      JWT_SECRET_KEY=${JWT_SECRET_KEY} \
      JWT_EXPIRATION=${JWT_EXPIRATION} \
      TZ=${TZ} \
      SENDGRID_API_KEY=${SENDGRID_API_KEY} \
      CI_COMMIT_SHA=${CI_COMMIT_SHA} \
      docker compose --project-name inkerstudio_production -f docker-compose.yml up -d
  environment:
    name: production
    url: https://www.inker.studio
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: manual
    - if: '$CI_COMMIT_BRANCH == "master"'
      when: manual
    - if: '$CI_COMMIT_TAG'
      when: manual

# Stage: Release
Create Release:
  stage: release
  extends: .release-job
  needs: ["Build Image"]
  script:
    - apk add --no-cache git openssh-client
    - npm install -g semantic-release @semantic-release/gitlab @semantic-release/git @semantic-release/changelog
    - npx semantic-release
  rules:
    - !reference [.release-branch, rules]

Push Release Image:
  stage: release
  extends: .docker-job
  needs: ["Create Release"]
  variables:
    BRANCH_TAG: $REGISTRY_URL/$CI_PROJECT_PATH:$CI_COMMIT_REF_SLUG
    SHA_TAG: $REGISTRY_URL/$CI_PROJECT_PATH:$CI_COMMIT_SHA
  script:
    - docker pull $SHA_TAG
    - docker tag $SHA_TAG $CONTAINER_RELEASE_IMAGE
    - docker push $CONTAINER_RELEASE_IMAGE
    # Tambi√©n taggeamos para staging si es la rama develop
    - |
      if [ "$CI_COMMIT_BRANCH" = "develop" ]; then
        docker tag $SHA_TAG $CONTAINER_STAGING_IMAGE
        docker push $CONTAINER_STAGING_IMAGE
      fi
  rules:
    - !reference [.release-tag, rules]