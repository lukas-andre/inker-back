You are a senior TypeScript developer working on a NestJS project with Fastify as the HTTP provider. The project uses TypeORM for database management and follows a clean architecture pattern.

PROJECT OVERVIEW
- This is a backend service built with NestJS v9
- Uses Fastify instead of Express for better performance
- Implements WebSocket functionality with Socket.io
- Uses Bull for queue management
- Integrates with AWS services
- Uses Firebase Admin for notifications
- Implements real-time features
- Uses TypeORM for database operations
- Includes comprehensive testing with Jest

ARCHITECTURAL PATTERNS
- Follow clean architecture principles with a clear separation of:
  * Domain layer (business rules)
  * Infrastructure layer (frameworks, tools, delivery mechanisms)
  * Use cases (application specific business rules)
- Each module should be self-contained with its own domain, infrastructure, and use cases
- Use dependency injection as provided by NestJS
- Implement proper error handling and domain exceptions

CODE STYLE
- Use TypeScript strict mode
- Prefer functional programming patterns where appropriate
- Use async/await over pure promises
- Use proper dependency injection
- Implement proper validation using class-validator
- Use swagger decorators for API documentation
- Follow SOLID principles

TESTING APPROACH
- Write unit tests for all use cases
- Write integration tests for infrastructure components
- Write e2e tests for API endpoints
- Use jest-mock for mocking
- Use ts-mockito for complex mocking scenarios
- Follow AAA (Arrange-Act-Assert) pattern in tests

FILE ORGANIZATION
- Keep related files close together
- Organize by feature rather than type
- Use proper barrel exports
- Keep index files clean and simple

NAMING CONVENTIONS
- Use PascalCase for classes and interfaces
- Use camelCase for methods and properties
- Use camelCase for file names
- Use descriptive names that reflect business domain
- Prefix interfaces with 'I'
- Suffix implementations with appropriate types (Controller, Service, etc.)

VALIDATION AND ERROR HANDLING
- Use class-validator decorators for DTO validation
- Implement custom validators when needed
- Use proper exception filters
- Implement proper error handling middleware
- Use proper HTTP status codes

API DESIGN
- Follow RESTful principles
- Use proper HTTP methods
- Implement proper request/response DTOs
- Use proper status codes
- Document with Swagger/OpenAPI
- Implement proper rate limiting
- Use proper security headers

SECURITY PRACTICES
- Implement proper authentication using JWT
- Use proper authorization guards
- Implement proper input validation
- Use proper security headers
- Implement proper rate limiting
- Handle sensitive data properly

DATABASE PRACTICES
- Use TypeORM repositories
- Implement proper migrations
- Use proper indexes
- Implement proper relationships
- Use proper cascading
- Implement proper data validation

QUEUE MANAGEMENT
- Use Bull for queue management
- Implement proper job handlers
- Implement proper error handling
- Use proper retry strategies
- Implement proper monitoring

REAL-TIME FEATURES
- Use Socket.io for real-time features
- Implement proper event handling
- Use proper room management
- Implement proper error handling
- Use proper authentication

DEPLOYMENT CONSIDERATIONS
- Use proper environment variables
- Implement proper logging
- Use proper health checks
- Implement proper monitoring
- Use proper CI/CD practices

# Inker Technical Documentation

## Architecture Overview

Inker is built as a modern, scalable backend service following Clean Architecture principles. The application is structured around distinct, domain-focused modules that encapsulate specific business capabilities.

### Key Architectural Patterns

- **Clean Architecture**: Clear separation between domain logic, application use cases, and infrastructure
- **Dependency Injection**: Leveraging NestJS's powerful DI container for loose coupling
- **Repository Pattern**: Abstracting data access behind repositories for flexibility in data sources
- **CQRS-inspired**: Separating commands and queries for better scalability and performance
- **Event-Driven**: Using events for cross-module communication when appropriate

### Technology Stack

- **Framework**: NestJS v9
- **HTTP Provider**: Fastify (higher performance than Express)
- **Database**: PostgreSQL with TypeORM
- **Real-time**: WebSocket functionality via Socket.io
- **Queue Management**: Bull for job processing and scheduling
- **Cloud Integration**: AWS services
- **Notifications**: Firebase Admin for push notifications
- **Testing**: Jest for comprehensive testing

## Core Components

### 1. Users Module

The Users module manages all user-related functionality including authentication, authorization, and profile management.

**Key Features**:
- User creation and management
- Role-based access control
- Permission management
- Account verification
- Password management
- User settings

**Domain Entities**:
- User
- Role
- Permission
- VerificationHash
- Settings

### 2. Artists Module

The Artists module handles all functionality related to tattoo artists using the platform.

**Key Features**:
- Artist profile management
- Portfolio management
- Availability tracking
- Skills and specializations
- Ratings and reviews

**Domain Entities**:
- Artist (extends User)
- Portfolio
- Availability
- Specialization

### 3. Customers Module

The Customers module manages all customer-related functionality.

**Key Features**:
- Customer profile management
- Appointment history
- Preferences
- Favorite artists

**Domain Entities**:
- Customer (extends User)
- Preference
- FavoriteArtist

### 4. Agenda Module

The Agenda module handles scheduling and appointment management.

**Key Features**:
- Appointment creation and management
- Availability management
- Calendar synchronization
- Booking confirmations
- Rescheduling and cancellations

**Domain Entities**:
- Appointment
- TimeSlot
- Availability
- BookingRequest

### 5. Tags Module

The Tags module provides categorization functionality across the application.

**Key Features**:
- Tag management
- Tagging functionality for various entities
- Tag-based search and filtering

**Domain Entities**:
- Tag
- TaggedItem

### 6. Schedulers Module

The Schedulers module manages recurring tasks and notifications.

**Key Features**:
- Appointment reminders
- Follow-up notifications
- System maintenance tasks
- Scheduled reports

**Domain Entities**:
- ScheduledTask
- Reminder
- NotificationTemplate

## Component Relationships

### User Interactions

- **Users → Artists**: Artists are specialized users with extended profiles
- **Users → Customers**: Customers are specialized users with customer-specific data
- **Users → Agenda**: Users (both artists and customers) interact with the Agenda for appointments

### Appointment Flow

1. **Customer** selects an **Artist** based on portfolio and availability
2. **Customer** books an appointment through the **Agenda** module
3. **Artist** receives notification and confirms/rejects
4. **Scheduler** sends reminders before the appointment
5. After appointment, **Customer** can leave reviews on the **Artist** profile

### Data Tagging Process

1. **Artists** tag their work with specific **Tags**
2. **Customers** can search for artists using **Tags**
3. **Tags** provide categorization for portfolios and search functionality

## Technical Considerations

### Database Strategy

The application uses TypeORM with a clear entity separation by module. UUID migration from incremental IDs improves security and scalability.

### Repository Pattern Implementation

All data access is abstracted through repositories, allowing:
- Easier testing through mocking
- Potential data source changes with minimal impact
- Cleaner business logic with data access concerns separated

### API Design

- RESTful endpoints organized by domain
- Consistent DTO pattern for request/response data
- Swagger documentation for all endpoints
- Proper validation using class-validator

### Authentication & Authorization

- JWT-based authentication
- Role-based access control
- Granular permissions system
- Security best practices implemented

### Performance Considerations

- Proper indexing for database tables
- Pagination for large result sets
- Optimized queries for high-traffic operations
- Caching strategies for read-heavy operations

### Scalability Approach

- Modular design allowing for horizontal scaling
- Stateless API design
- Queue-based processing for heavy operations
- Database connection pooling and optimization

## Areas for Improvement

### Technical Debt

- Complete migration from incremental IDs to UUIDs across all entities
- Standardize naming conventions (changing "providers" to "repositories" consistently)
- Improve test coverage, particularly for newer modules

### Feature Enhancements

- Implement more robust caching strategy
- Add better logging and monitoring
- Enhance error handling with more specific error types
- Improve WebSocket implementation for real-time features

### Architectural Improvements

- Consider microservices approach for further scalability
- Implement event sourcing for critical data flows
- Enhance CQRS implementation for better separation of concerns
- Add more comprehensive integration testing

## Deployment Considerations

- Environment-specific configuration management
- CI/CD pipeline setup
- Health checks and monitoring
- Backup and recovery strategy
- Scaling policies 